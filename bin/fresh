#!/bin/bash -e

FRESH_RCFILE="${FRESH_RCFILE:-$HOME/.freshrc}"
FRESH_PATH="${FRESH_PATH:-$HOME/.fresh}"
FRESH_LOCAL="${FRESH_LOCAL:-$HOME/.dotfiles}"

set -o pipefail

fresh_install() {
  # create new output directory
  [ ! -e "$FRESH_PATH/build.new" ] || rm -rf "$FRESH_PATH/build.new"
  mkdir -p "$FRESH_PATH/build.new"
  echo "export PATH=\"\$HOME/bin:\$PATH\"" >> "$FRESH_PATH/build.new/shell.sh"

  # load the freshrc file
  if [ -e "$FRESH_RCFILE" ]; then
    source "$FRESH_RCFILE"
  fi

  # safety check to ensure the user doesn't lock themselves out
  if [[ -z "$FRESH_NO_BIN_CHECK" ]] && [[ ! -x "$FRESH_PATH/build.new/bin/fresh" ]]; then
    _fatal_error "It looks you do not have fresh in your freshrc file. This could result
in difficulties running \`fresh\` later. You probably want to add a line like
the following using \`fresh edit\`:

  fresh freshshell/fresh bin/fresh --bin

To disable this error, add \`FRESH_NO_BIN_CHECK=true\` in your freshrc file."
  fi

  # output files should be read-only
  find "$FRESH_PATH/build.new" -type f -exec chmod -w {} \;

  # move output into place
  [ ! -e "$FRESH_PATH/build" ] || rm -rf "$FRESH_PATH/build"
  mv "$FRESH_PATH/build.new" "$FRESH_PATH/build"

  if [ ! "$1" == "--quiet" ];
  then
    echo $'Your dot files are now \033[1;32mfresh\033[0m.'
  fi
}

# freshrc DSL
fresh() {
  parse_fresh_dsl_args "$@"

  # clone or update source repo
  if [ -n "$REPO_NAME" ]; then
    local REPO_DIR="$FRESH_PATH/source/$REPO_NAME"
    mkdir -p "$(dirname "$REPO_DIR")"
    if ! [ -e "$REPO_DIR" ]; then
      git clone "http://github.com/$REPO_NAME" "$REPO_DIR"
    fi
    local SOURCE_DIR="$REPO_DIR"
  else
    local SOURCE_DIR="$FRESH_LOCAL"
  fi

  # check the source file exists
  if [[ $(find "$SOURCE_DIR" -path "$SOURCE_DIR/$FILE_NAME" | wc -l) -lt 1 ]]; then
    # but not if we are locking to a git ref
    # since we would be checking the working tree
    if [[ ! -n "$REF" ]]; then
      _fatal_error "Could not find \"$FILE_NAME\" source file."
    fi
  fi

  case "${MODE:-shell}" in
    shell)
      _fresh_shell
      ;;
    file)
      _fresh_file
      ;;
    bin)
      _fresh_bin
      ;;
    *)
      _fatal_error "Unknown mode: $MODE"
      ;;
  esac
}

_file_list() {
  if [[ -n "$REF" ]]; then
    cd "$SOURCE_DIR"
    local MATCHED=0
    while read PATH; do
      if [[ "$PATH" == $FILE_NAME ]]; then
        echo "$PATH"
        MATCHED=1
      fi
    done < <(git ls-tree -r --name-only "$REF")
    cd - > /dev/null
    [[ "$MATCHED" == 1 ]]
  else
    find "$SOURCE_DIR" -path "$SOURCE_DIR/$FILE_NAME"
  fi | sort
}

_source_file_contents() {
  if [[ -n "$REF" ]]; then
    cd "$SOURCE_DIR"
    git show "$REF:$SOURCE_FILE"
    cd - > /dev/null
  else
    cat "$SOURCE_FILE"
  fi
}

_file_marker() {
  echo -n "$MARKER fresh:"
  if [[ -n "$REPO_NAME" ]]; then
    echo -n " $REPO_NAME"
  fi
  echo -n " ${SOURCE_FILE#$SOURCE_DIR/}"
  if [[ -n "$REF" ]]; then
    echo -n " @ $REF"
  fi
  echo
}

_fresh_shell() {
  _file_list | while read SOURCE_FILE
  do
    echo >> "$FRESH_PATH/build.new/shell.sh"
    MARKER='#' _file_marker >> "$FRESH_PATH/build.new/shell.sh"
    echo >> "$FRESH_PATH/build.new/shell.sh"
    _source_file_contents >> "$FRESH_PATH/build.new/shell.sh"
  done
}

_fresh_file() {
  _file_list | while read SOURCE_FILE
  do
    if [ -n "$MODE_ARG" ]; then
      if echo "$MODE_ARG" | grep -q '^[~/]'; then
        DEST_NAME="$(basename "$MODE_ARG" | sed 's/^\.//')"
        SYMLINK_PATH="$MODE_ARG"
      else
        if echo "$MODE_ARG" | grep -q '^\.\.'; then
          _fatal_error "Relative paths must be inside build dir."
        fi
        DEST_NAME="$MODE_ARG"
        SYMLINK_PATH=""
      fi
    else
      DEST_NAME="$(basename "$SOURCE_FILE" | sed 's/^\.//')"
      SYMLINK_PATH="~/.$DEST_NAME"
    fi

    mkdir -p "$(dirname "$FRESH_PATH/build.new/$DEST_NAME")"

    if [[ -n "$MARKER" ]]; then
      if [[ -e "$FRESH_PATH/build.new/$DEST_NAME" ]]; then
        echo >> "$FRESH_PATH/build.new/$DEST_NAME"
      fi
      _file_marker >> "$FRESH_PATH/build.new/$DEST_NAME"
      echo >> "$FRESH_PATH/build.new/$DEST_NAME"
    fi

    _source_file_contents >> "$FRESH_PATH/build.new/$DEST_NAME"

    if [[ -n "$SYMLINK_PATH" ]]; then
      SYMLINK_PATH="$(eval echo "$SYMLINK_PATH")"
      if ! [ -L "$SYMLINK_PATH" ]; then
        mkdir -p "$(dirname "$SYMLINK_PATH")"
        ln -s "$FRESH_PATH/build/$DEST_NAME" "$SYMLINK_PATH"
      fi
    fi
  done
}

_fresh_bin() {
  _file_list | while read SOURCE_FILE
  do
    if [ -n "$MODE_ARG" ]; then
      if echo "$MODE_ARG" | grep -q '^[~/]'; then
        DEST_NAME="$(basename "$MODE_ARG")"
        SYMLINK_PATH="$MODE_ARG"
      else
        _fatal_error "--bin file paths cannot be relative."
      fi
    else
      DEST_NAME="$(basename "$SOURCE_FILE")"
      SYMLINK_PATH="~/bin/$DEST_NAME"
    fi
    mkdir -p "$FRESH_PATH/build.new/bin" ~/bin
    _source_file_contents >> "$FRESH_PATH/build.new/bin/$DEST_NAME"
    chmod +x "$FRESH_PATH/build.new/bin/$DEST_NAME"
    SYMLINK_PATH="$(eval echo "$SYMLINK_PATH")"
    if ! [ -L "$SYMLINK_PATH" ]; then
      mkdir -p "$(dirname "$SYMLINK_PATH")"
      ln -s "$FRESH_PATH/build/bin/$DEST_NAME" "$SYMLINK_PATH"
    fi
  done
}

function parse_fresh_dsl_args() {
  MODE=
  MODE_ARG=
  REPO_NAME=
  FILE_NAME=
  REF=
  MARKER=
  while [ $# -gt 0 ]
  do
    case "$1" in
      --file|--file=*|--bin|--bin=*)
        if [ -n "$MODE" ]; then
          _fatal_error "Cannot have more than one mode."
        fi
        MODE="$(echo "$1" | sed -e 's/^--//' -e 's/=.*//')"
        MODE_ARG="$(echo "$1" | sed 's/^--[^=]*=*//')"
        ;;
      --ref)
        _fatal_error "You must specify a Git reference."
        ;;
      --ref=*)
        REF="$(echo "$1" | sed 's/^--[^=]*=*//')"
        ;;
      --marker|--marker=*)
        if [[ "$MODE" != file ]]; then
          _fatal_error "--marker is only valid with --file."
        fi
        if [[ "$1" == --marker ]]; then
          MARKER='#'
        else
          MARKER="$(echo "$1" | sed 's/^--[^=]*=*//')"
          if [[ -z "$MARKER" ]]; then
            _fatal_error "Marker not specified."
          fi
        fi
        ;;
      -*)
        _fatal_error "Unknown option: $1"
        ;;
      *)
        if [ -n "$FILE_NAME" ]; then
          if [ -n "$REPO_NAME" ]; then
            _fatal_error "Expected 1 or 2 args."
          fi
          REPO_NAME="$FILE_NAME"
          FILE_NAME="$1"
        else
          FILE_NAME="$1"
        fi
        ;;
    esac
    shift
  done
  if [ -z "$FILE_NAME" ]; then
    _fatal_error "Filename is required"
  fi
}

fresh_install_with_latest_binary() {
  local FRESH_BIN="$FRESH_PATH/build/bin/fresh"
  if [[ -x "$FRESH_BIN" ]]; then
    "$FRESH_BIN" install
  fi
}

fresh_update() {
  local GIT_OUTPUT_FILE="$(mktemp "${TMPDIR:-/tmp}/fresh.XXXXXX")"
  mkdir -p "$FRESH_PATH/logs"
  local LOG_FILE="$FRESH_PATH/logs/update-$(date +%Y-%m-%d-%H%M%S).log"
  find $FRESH_PATH/source -type d -name '.git' | sort | while read DIR; do
    local DIR="$(dirname "$DIR")"
    local REPO_NAME="$(_repo_name_from_source_path "$DIR")"
    echo "* Updating $REPO_NAME" | tee -a "$LOG_FILE"
    cd "$DIR"
    git pull --rebase 2>&1 | tee "$GIT_OUTPUT_FILE" | sed 's/^/| /' | tee -a "$LOG_FILE"
    perl -n -e'/^ {2,}([0-9a-f]{7,})\.\.([0-9a-f]{7,}) / && print "| <https://github.com/'"$REPO_NAME"'/compare/$1...$2>\n"' "$GIT_OUTPUT_FILE" | tee -a "$LOG_FILE"
    local GIT_RESULT="${PIPESTATUS[0]}"
    rm "$GIT_OUTPUT_FILE"
    if [ "$GIT_RESULT" -ne 0 ]; then
      _fatal_error "Update failed."
    fi
    cd - > /dev/null
  done
}

_repo_name_from_source_path() {
  echo "$1" | awk -F/ '{OFS="/"; print $(NF-1), $(NF-0)}'
}

fresh_edit() {
  "${EDITOR:-vi}" "$FRESH_RCFILE"
}

fresh_search() {
  if [[ "$#" -gt 0 ]]; then
    RESULTS="$(curl -sS http://api.freshshell.com/directory --get --data-urlencode q="$*")"
    if [[ -n "$RESULTS" ]]; then
      echo "$RESULTS"
    else
      _fatal_error "No results."
    fi
  else
    _fatal_error "No search query given."
  fi
}

fresh_help() {
cat <<EOF
Keep your dot files fresh.

The following commands will install/update configuration files
as specified in your ${FRESH_RCFILE/#$HOME/~} file.

See http://freshshell.com/readme for more documentation.

usage: fresh <command>

Available commands:
    install         Build shell configuration and relevant symlinks (default)
    update          Update from source repos and rebuild
    search <query>  Search the fresh directory
    edit            Open freshrc for editing
    help            Show this help
EOF
}

_fatal_error() {
  echo $'\033[4;31mError\033[0m:' "$1" >&2
  exit 1
}

_prevent_invalid_arguments() {
  if [ -n "$2" ]; then
    _fatal_error "Invalid arguments"
  fi
}

main() {
  case "$1" in
    help|--help)
      fresh_help
      ;;
    install|'')
      _prevent_invalid_arguments "$@"
      fresh_install
      ;;
    update)
      _prevent_invalid_arguments "$@"
      fresh_update
      fresh_install --quiet
      fresh_install_with_latest_binary
      ;;
    edit)
      _prevent_invalid_arguments "$@"
      fresh_edit
      ;;
    search)
      shift
      fresh_search "$@"
      ;;
    *)
      _fatal_error "Unknown option: $1"
      ;;
  esac
}

if [ -z "$__FRESH_TEST_MODE" ]; then
  main "$@"
fi
